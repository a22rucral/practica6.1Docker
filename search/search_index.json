{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Practica 6.1 Docker.","text":""},{"location":"#porque-usar-docker","title":"\u00bfPorque usar Docker?","text":"<p>Al usar docker sobre apliaciones, obtendremos varias ventajas. Una de ellas es la configuraci\u00f3n r\u00e1pida y uniforme del entorno de desarrollo, esto evitar\u00e1 problemas de compatibilidad entre equipos. Permite despliegues m\u00e1s \u00e1giles. Tambi\u00e9n simplifica la gesti\u00f3n de m\u00faltiples entornos mediante cambios de variables de entorno. </p>"},{"location":"#despliegue-con-docker","title":"Despliegue con Docker.","text":"<p>Clonaremos el siguiente repositorio en nuestra m\u00e1quina con el siguiente comando. </p> <pre><code>$ git clone https://github.com/raul-profesor/DAW_practica_6.1_2024.git\n</code></pre> <p>Tras esto, dentro de la aplicaci\u00f3n ya viene el archivo Dockerfile, el cual es necesario dentro del directorio para construir la imagen y correr el contenedor. Su contenido es el siguiente. </p> <p></p>"},{"location":"#explicacion-del-archivo","title":"Explicaci\u00f3n del archivo","text":"<ol> <li>FROM -&gt; Indica que vamos a utilizar la imagen de Docker Hub oficial de Node, en su versi\u00f3n 18.16.0 junto con Alpine. </li> <li>RUN -&gt; Ejecuta un comando en una nueva capa de imagen. </li> <li>WORKDIR -&gt; Define el directorio sobre el que se ejecutar\u00e1n las subsiguientes instrucciones del Dockerfile. </li> <li>COPY -&gt; Copia los archivos que le indiquemos dentro del contenedor, en este caso ser\u00eda el package.json.</li> <li>RUN -&gt; Ejecutamos el comando que nos instala las dependencias que se indican en el archivo package.json. </li> <li>COPY -&gt; Copiamos todos los archivos de nuestro directorio /src al contenedor. </li> <li>EXPOSE -&gt; Nos permite documentar que puertos est\u00e1n expuestos.</li> <li>CMD -&gt; Permite ejecutar un comando dentro del contenedor. En este caso iniciaremos la aplcaci\u00f3n. </li> </ol> <p>El siguiente paso es hacer un build de la imagen del Docker. Indicaremos que \u00e9sta se llama librodirecciones y que haga el build con el contexto del directorio actual de trabajo as\u00ed como del Dockerfile que hay en el </p> <p></p> <p>Ahora iniciamos el contenedor con nuestra aplicaci\u00f3n. Con -p le decimos que escuche conexiones entrantes de cualquier m\u00e1quina en el puerto 3000 de nuestra m\u00e1quina anfitri\u00f3n. Con la opci\u00f3n -d lo haremos correr en modo demonio en el background: </p> <p></p> <p></p>"},{"location":"#docker-compose","title":"Docker Compose.","text":""},{"location":"#que-es-docker-compose","title":"\u00bfQue es Docker Compose?","text":"<p>Es una herramienta que permite definir y administrar varios contenedores de Docker en un solo archivo YAML. Facilita la ejecuci\u00f3n de aplicaciones que dependen de varios servicios, como una API con una base de datos. </p> <p>El siguiente archivo es el YAML del que hemos previamente hablado. </p> <p></p> <p>Ahora ejecutaremos el siguiente comando para levantar nuestra infraestructura basada en contenedores:</p> <p></p> <p>Este comando crear\u00e1 las tablas necesarias en la base de datos. Y construiremos nuestros contenedores a partir de las im\u00e1genes. </p> <p></p> <p>Ya construidas las im\u00e1genes, podemos levantar los contenedores. Correremos unos test para comprobar que la aplicaci\u00f3n funciona correctamente. </p> <p></p> <p></p> <p>Comprobaciones para comprobar que la aplicaci\u00f3n junto con la BBDD funciona correctamente. </p> <p></p> <p></p>"}]}